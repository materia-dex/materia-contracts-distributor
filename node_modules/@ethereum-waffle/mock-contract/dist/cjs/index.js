"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const Doppelganger_json_1 = __importDefault(require("./Doppelganger.json"));
async function deploy(signer) {
    const factory = new ethers_1.ContractFactory(Doppelganger_json_1.default.abi, Doppelganger_json_1.default.bytecode, signer);
    return factory.deploy();
}
function stub(mockContract, encoder, func, params) {
    const callData = params
        ? mockContract.interface.encodeFunctionData(func, params)
        : mockContract.interface.getSighash(func);
    return {
        returns: async (...args) => {
            if (!func.outputs)
                return;
            const encoded = encoder.encode(func.outputs, args);
            await mockContract.__waffle__mockReturns(callData, encoded);
        },
        reverts: async () => mockContract.__waffle__mockReverts(callData),
        withArgs: (...args) => stub(mockContract, encoder, func, args)
    };
}
function createMock(abi, mockContractInstance) {
    const { functions } = new ethers_1.utils.Interface(abi);
    const encoder = new ethers_1.utils.AbiCoder();
    return Object.values(functions).reduce((acc, func) => {
        const stubbed = stub(mockContractInstance, encoder, func);
        return {
            ...acc,
            [func.name]: stubbed,
            [func.format()]: stubbed
        };
    }, {});
}
async function deployMockContract(signer, abi) {
    const mockContractInstance = await deploy(signer);
    const mock = createMock(abi, mockContractInstance);
    const mockedContract = new ethers_1.Contract(mockContractInstance.address, abi, signer);
    mockedContract.mock = mock;
    return mockedContract;
}
exports.deployMockContract = deployMockContract;
