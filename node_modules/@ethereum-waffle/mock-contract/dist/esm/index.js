import { Contract, ContractFactory, utils } from 'ethers';
import DoppelgangerContract from './Doppelganger.json';
async function deploy(signer) {
    const factory = new ContractFactory(DoppelgangerContract.abi, DoppelgangerContract.bytecode, signer);
    return factory.deploy();
}
function stub(mockContract, encoder, func, params) {
    const callData = params
        ? mockContract.interface.encodeFunctionData(func, params)
        : mockContract.interface.getSighash(func);
    return {
        returns: async (...args) => {
            if (!func.outputs)
                return;
            const encoded = encoder.encode(func.outputs, args);
            await mockContract.__waffle__mockReturns(callData, encoded);
        },
        reverts: async () => mockContract.__waffle__mockReverts(callData),
        withArgs: (...args) => stub(mockContract, encoder, func, args)
    };
}
function createMock(abi, mockContractInstance) {
    const { functions } = new utils.Interface(abi);
    const encoder = new utils.AbiCoder();
    return Object.values(functions).reduce((acc, func) => {
        const stubbed = stub(mockContractInstance, encoder, func);
        return {
            ...acc,
            [func.name]: stubbed,
            [func.format()]: stubbed
        };
    }, {});
}
export async function deployMockContract(signer, abi) {
    const mockContractInstance = await deploy(signer);
    const mock = createMock(abi, mockContractInstance);
    const mockedContract = new Contract(mockContractInstance.address, abi, signer);
    mockedContract.mock = mock;
    return mockedContract;
}
